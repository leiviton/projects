(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{mHm1:function(t,e,i){"use strict";i.d(e,"f",function(){return d}),i.d(e,"h",function(){return u}),i.d(e,"k",function(){return w}),i.d(e,"g",function(){return z}),i.d(e,"b",function(){return f}),i.d(e,"c",function(){return g}),i.d(e,"d",function(){return x}),i.d(e,"i",function(){return l}),i.d(e,"e",function(){return n}),i.d(e,"j",function(){return s}),i.d(e,"a",function(){return m}),i.d(e,"l",function(){return a});var r=i("8Y7J");let a=(()=>(class{constructor(t){this.templateRef=t}}))(),s=(()=>{class t{constructor(){this.navigationSymbol={symbol:""},this.completed=!1,this.selected=!1,this.defaultSelected=!1,this.optional=!1,this.canEnter=!0,this.canExit=!0,this.stepEnter=new r.m,this.stepExit=new r.m}get hidden(){return!this.selected}static canTransitionStep(t,e){return typeof t==typeof!0?Promise.resolve(t):t instanceof Function?Promise.resolve(t(e)):Promise.reject(new Error(`Input value '${t}' is neither a boolean nor a function`))}enter(t){this.stepEnter.emit(t)}exit(t){this.stepExit.emit(t)}canEnterStep(e){return t.canTransitionStep(this.canEnter,e)}canExitStep(e){return t.canTransitionStep(this.canExit,e)}}return t})();class n extends s{constructor(){super(...arguments),this.stepExit=new r.m,this.canExit=!1}enter(t){this.completed=!0,this.stepEnter.emit(t)}exit(t){this.completed=!1,this.stepExit.emit(t)}}let d=(()=>(class extends n{}))();const o=function(){var t={Forwards:0,Backwards:1,Stay:2};return t[t.Forwards]="Forwards",t[t.Backwards]="Backwards",t[t.Stay]="Stay",t}();class h{constructor(t){this.wizardState=t}goToPreviousStep(t,e){this.wizardState.hasPreviousStep()&&this.goToStep(this.wizardState.currentStepIndex-1,t,e)}goToNextStep(t,e){this.wizardState.hasNextStep()&&this.goToStep(this.wizardState.currentStepIndex+1,t,e)}}class S extends h{constructor(t){super(t)}canGoToStep(t){const e=this.wizardState.hasStep(t),i=this.wizardState.getMovingDirection(t);return Promise.resolve(e).then(t=>t?this.wizardState.currentStep.canExitStep(i):Promise.resolve(!1)).then(e=>e?this.wizardState.getStepAtIndex(t).canEnterStep(i):Promise.resolve(!1))}goToStep(t,e,i){this.canGoToStep(t).then(r=>{if(r){const r=this.wizardState.getMovingDirection(t);e&&e.emit(),this.wizardState.currentStep.completed=!0,this.wizardState.currentStep.exit(r),this.wizardState.currentStep.selected=!1,this.wizardState.currentStepIndex=t,this.wizardState.currentStep.enter(r),this.wizardState.currentStep.selected=!0,i&&i.emit()}else this.wizardState.currentStep.exit(o.Stay),this.wizardState.currentStep.enter(o.Stay)})}isNavigable(t){return!0}reset(){if(!this.wizardState.hasStep(this.wizardState.defaultStepIndex))throw new Error(`The wizard doesn't contain a step with index ${this.wizardState.defaultStepIndex}`);this.wizardState.wizardSteps.forEach(t=>{t.completed=!1,t.selected=!1}),this.wizardState.currentStepIndex=this.wizardState.defaultStepIndex,this.wizardState.currentStep.selected=!0,this.wizardState.currentStep.enter(o.Forwards)}}class p extends h{constructor(t){super(t)}canGoToStep(t){const e=this.wizardState.hasStep(t),i=this.wizardState.getMovingDirection(t);return Promise.resolve(e).then(t=>t?this.wizardState.currentStep.canExitStep(i):Promise.resolve(!1)).then(e=>e?this.wizardState.getStepAtIndex(t).canEnterStep(i):Promise.resolve(!1)).then(e=>{if(e){const e=this.wizardState.wizardSteps.filter((e,i)=>i<t).every(t=>t.completed||t.optional||t.selected);return Promise.resolve(!(this.wizardState.getStepAtIndex(t)instanceof n)||e)}return Promise.resolve(!1)})}goToStep(t,e,i){this.canGoToStep(t).then(r=>{if(r){const r=this.wizardState.getMovingDirection(t);e&&e.emit(),this.wizardState.currentStep.completed=!0,this.wizardState.currentStep.exit(r),this.wizardState.currentStep.selected=!1,this.wizardState.currentStepIndex=t,this.wizardState.currentStep.enter(r),this.wizardState.currentStep.selected=!0,i&&i.emit()}else this.wizardState.currentStep.exit(o.Stay),this.wizardState.currentStep.enter(o.Stay)})}isNavigable(t){return!(this.wizardState.getStepAtIndex(t)instanceof n)||this.wizardState.wizardSteps.filter((e,i)=>i<t).every(t=>t.completed||t.optional||t.selected)}reset(){if(!this.wizardState.hasStep(this.wizardState.defaultStepIndex))throw new Error(`The wizard doesn't contain a step with index ${this.wizardState.defaultStepIndex}`);if(this.wizardState.getStepAtIndex(this.wizardState.defaultStepIndex)instanceof n&&1!==this.wizardState.wizardSteps.length)throw new Error(`The default step index ${this.wizardState.defaultStepIndex} references a completion step`);this.wizardState.wizardSteps.forEach(t=>{t.completed=!1,t.selected=!1}),this.wizardState.currentStepIndex=this.wizardState.defaultStepIndex,this.wizardState.currentStep.selected=!0,this.wizardState.currentStep.enter(o.Forwards)}}class c extends h{constructor(t){super(t)}canGoToStep(t){const e=this.wizardState.hasStep(t),i=this.wizardState.getMovingDirection(t);return Promise.resolve(e).then(t=>t?this.wizardState.currentStep.canExitStep(i):Promise.resolve(!1)).then(e=>e?this.wizardState.getStepAtIndex(t).canEnterStep(i):Promise.resolve(!1)).then(e=>e?Promise.resolve(this.wizardState.wizardSteps.filter((e,i)=>i<t&&i!==this.wizardState.currentStepIndex).every(t=>t.completed||t.optional)):Promise.resolve(!1))}goToStep(t,e,i){this.canGoToStep(t).then(r=>{if(r){const r=this.wizardState.getMovingDirection(t);e&&e.emit(),this.wizardState.currentStep.completed=!0,this.wizardState.currentStep.exit(r),this.wizardState.currentStep.selected=!1,this.wizardState.wizardSteps.filter((e,i)=>this.wizardState.currentStepIndex>t&&i>t).forEach(t=>t.completed=!1),this.wizardState.currentStepIndex=t,this.wizardState.currentStep.enter(r),this.wizardState.currentStep.selected=!0,i&&i.emit()}else this.wizardState.currentStep.exit(o.Stay),this.wizardState.currentStep.enter(o.Stay)})}isNavigable(t){return t<this.wizardState.currentStepIndex}reset(){if(!this.wizardState.hasStep(this.wizardState.defaultStepIndex))throw new Error(`The wizard doesn't contain a step with index ${this.wizardState.defaultStepIndex}`);if(this.wizardState.wizardSteps.filter((t,e)=>e<this.wizardState.defaultStepIndex).some(t=>!t.optional))throw new Error(`The default step index ${this.wizardState.defaultStepIndex} is located after a non optional step`);this.wizardState.wizardSteps.forEach(t=>{t.completed=!1,t.selected=!1}),this.wizardState.currentStepIndex=this.wizardState.defaultStepIndex,this.wizardState.currentStep.selected=!0,this.wizardState.currentStep.enter(o.Forwards)}}let l=(()=>(class{constructor(){this.wizardSteps=[],this.currentStepIndex=-1,this._defaultStepIndex=0}get defaultStepIndex(){const t=this.wizardSteps.find(t=>t.defaultSelected);return t?this.getIndexOfStep(t):this._defaultStepIndex}set defaultStepIndex(t){this._defaultStepIndex=t}get currentStep(){return this.hasStep(this.currentStepIndex)?this.wizardSteps[this.currentStepIndex]:null}get completed(){return this.wizardSteps.every(t=>t.completed||t.optional)}updateNavigationMode(t){this.navigationMode=function(e,i){switch(t){case"free":return new S(i);case"semi-strict":return new p(i);case"strict":default:return new c(i)}}(0,this)}updateWizardSteps(t){this.wizardSteps.length>0&&this.currentStepIndex>-1&&(this.currentStepIndex=t.indexOf(this.wizardSteps[this.currentStepIndex])),this.wizardSteps=t}hasStep(t){return this.wizardSteps.length>0&&0<=t&&t<this.wizardSteps.length}hasPreviousStep(){return this.hasStep(this.currentStepIndex-1)}hasNextStep(){return this.hasStep(this.currentStepIndex+1)}isLastStep(){return this.wizardSteps.length>0&&this.currentStepIndex===this.wizardSteps.length-1}getStepAtIndex(t){if(!this.hasStep(t))throw new Error(`Expected a known step, but got stepIndex: ${t}.`);return this.wizardSteps[t]}getIndexOfStepWithId(t){return this.wizardSteps.findIndex(e=>e.stepId===t)}getIndexOfStep(t){return this.wizardSteps.indexOf(t)}getMovingDirection(t){return t>this.currentStepIndex?o.Forwards:t<this.currentStepIndex?o.Backwards:o.Stay}}))(),u=(()=>(class{constructor(t){this.wizardState=t,this.direction="left-to-right"}get navigationMode(){return this.wizardState.navigationMode}get wizardSteps(){switch(this.direction){case"right-to-left":return this.wizardState.wizardSteps.slice().reverse();case"left-to-right":default:return this.wizardState.wizardSteps}}get numberOfWizardSteps(){return this.wizardState.wizardSteps.length}isCurrent(t){return t.selected&&!t.completed&&!this.wizardState.completed}isDone(t){return t.completed&&!t.selected||this.wizardState.completed}isDefault(t){return!(t.optional||t.completed||t.selected||this.wizardState.completed)}isEditing(t){return t.selected&&t.completed&&!this.wizardState.completed}isOptional(t){return t.optional&&!t.completed&&!t.selected&&!this.wizardState.completed}isNavigable(t){return!t.selected&&!this.wizardState.disableNavigationBar&&this.navigationMode.isNavigable(this.wizardState.getIndexOfStep(t))}}))(),w=(()=>(class extends s{}))(),z=(()=>(class{constructor(t){this.model=t,this.navBarLocation="top",this.navBarLayout="small",this.navBarDirection="left-to-right",this.navigationMode="strict",this.defaultStepIndex=0,this.disableNavigationBar=!1}get horizontalOrientation(){return"top"===this.navBarLocation||"bottom"===this.navBarLocation}get verticalOrientation(){return"left"===this.navBarLocation||"right"===this.navBarLocation}get navigation(){return this.model.navigationMode}ngOnChanges(t){for(const e of Object.keys(t)){const i=t[e];if(!i.firstChange)switch(e){case"defaultStepIndex":this.model.defaultStepIndex=parseInt(i.currentValue,10);break;case"disableNavigationBar":this.model.disableNavigationBar=i.currentValue;break;case"navigationMode":this.model.updateNavigationMode(i.currentValue)}}}ngAfterContentInit(){this.wizardSteps.changes.subscribe(t=>{this.model.updateWizardSteps(t.toArray())}),this.model.disableNavigationBar=this.disableNavigationBar,this.model.defaultStepIndex=this.defaultStepIndex,this.model.updateWizardSteps(this.wizardSteps.toArray()),this.model.updateNavigationMode(this.navigationMode),this.navigation.reset()}}))(),f=(()=>(class{constructor(t,e){this.wizardState=t,this.wizardStep=e,this.preFinalize=new r.m,this.postFinalize=new r.m}get finalize(){return this.preFinalize}set finalize(t){this.preFinalize=t}get destinationStep(){let t;if(this.targetStep.hasOwnProperty("stepIndex"))t=this.targetStep.stepIndex;else if(function(t){return t.hasOwnProperty("stepId")&&!(t instanceof s)}(this.targetStep))t=this.wizardState.getIndexOfStepWithId(this.targetStep.stepId);else if(function(t){return t.hasOwnProperty("stepOffset")}(this.targetStep)&&null!==this.wizardStep)t=this.wizardState.getIndexOfStep(this.wizardStep)+this.targetStep.stepOffset;else{if(!(this.targetStep instanceof s))throw new Error("Input 'targetStep' is neither a WizardStep, StepOffset, StepIndex or StepId");t=this.wizardState.getIndexOfStep(this.targetStep)}return t}get navigationMode(){return this.wizardState.navigationMode}onClick(t){this.navigationMode.goToStep(this.destinationStep,this.preFinalize,this.postFinalize)}}))(),g=(()=>(class{constructor(t){this.wizardState=t,this.preFinalize=new r.m,this.postFinalize=new r.m}get finalize(){return this.preFinalize}set finalize(t){this.preFinalize=t}get navigationMode(){return this.wizardState.navigationMode}onClick(t){this.navigationMode.goToNextStep(this.preFinalize,this.postFinalize)}}))(),x=(()=>(class{constructor(t){this.wizardState=t,this.preFinalize=new r.m,this.postFinalize=new r.m}get finalize(){return this.preFinalize}set finalize(t){this.preFinalize=t}get navigationMode(){return this.wizardState.navigationMode}onClick(t){this.navigationMode.goToPreviousStep(this.preFinalize,this.postFinalize)}}))(),m=(()=>{class t{static forRoot(){return{ngModule:t,providers:[]}}}return t})()}}]);